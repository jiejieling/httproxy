#!/usr/bin/env python3import asyncioimport loggingimport sysimport urllib.parseimport argparseimport daemonfrom daemon import pidfileimport util__NAME__ = 'ZZHttpProxy'__VERSION__ = "2.0"logger = logging.getLogger('zzapp')class AsyncProxy:    def __init__(self, host, port):        self.host = host        self.port = port    async def start(self):        server = await asyncio.start_server(            self.handle_client, self.host, self.port        )        addr = server.sockets[0].getsockname()        logger.info(f"Serving HTTP on {addr[0]}:{addr[1]}")        async with server:            await server.serve_forever()    async def handle_client(self, reader, writer):        addr = writer.get_extra_info('peername')        logger.debug(f"Accepted connection from {addr}")        try:            line = await reader.readline()            if not line:                logger.debug(f"Client {addr} disconnected before sending request.")                return            try:                request_line = line.decode('iso-8859-1').rstrip()                parts = request_line.split()                if len(parts) == 3:                    method, path, version = parts                elif len(parts) == 2:                    method, path = parts                    version = "HTTP/0.9"                else:                    raise ValueError("Invalid request line")            except ValueError:                logger.warning(f"Malformed request line from {addr}: {line}")                return            logger.info(f"Request from {addr}: {method} {path} {version}")            if method == 'CONNECT':                await self.handle_connect(reader, writer, path)            else:                await self.handle_http(reader, writer, method, path, version)        except Exception as e:            logger.error(f"Error handling request from {addr}: {e}", exc_info=True)        finally:            if not writer.is_closing():                logger.debug(f"Closing connection to {addr} in top-level handler.")                writer.close()                try:                    await writer.wait_closed()                except Exception:                    pass            logger.debug(f"Connection to {addr} is fully closed.")    async def handle_connect(self, client_reader, client_writer, netloc):        host_port = AsyncProxy._get_host_port(netloc)        if not host_port:            return        host, port = host_port        client_addr = client_writer.get_extra_info('peername')        logger.debug(f"[{client_addr}] CONNECT request to {host}:{port}")        try:            upstream_reader, upstream_writer = await asyncio.open_connection(host, port)        except Exception as e:            logger.error(f"[{client_addr}] Failed to connect to {host}:{port}: {e}")            client_writer.write(b"HTTP/1.1 502 Bad Gateway\r\n\r\n")            await client_writer.drain()            return        upstream_addr = upstream_writer.get_extra_info('peername')        logger.debug(f"[{client_addr}] Connection to upstream {upstream_addr} established.")        client_writer.write(b"HTTP/1.1 200 Connection established\r\n")        client_writer.write(f"Proxy-agent: {__NAME__}/{__VERSION__}\r\n".encode())        client_writer.write(b"\r\n")        await client_writer.drain()        logger.debug(f"[{client_addr}] Sent 200 OK to client, starting pipe.")        await self.pipe_bi(client_reader, client_writer, upstream_reader, upstream_writer)        logger.debug(f"[{client_addr}] pipe_bi finished for {upstream_addr}.")    async def handle_http(self, client_reader, client_writer, method, path, version):        scm, netloc, path, params, query, fragment = urllib.parse.urlparse(path, 'http')        if not netloc:            logger.warning(f"Bad URL: {path}")            client_writer.write(b"HTTP/1.1 400 Bad Request\r\n\r\n")            await client_writer.drain()            return        host_port = self._get_host_port(netloc)        if not host_port:            return        host, port = host_port        headers = {}        while True:            line = await client_reader.readline()            if not line or line == b'\r\n':                break            try:                key, value = line.decode('iso-8859-1').split(':', 1)                headers[key.strip()] = value.strip()            except:                pass        logger.debug(f"Proxying HTTP {method} to {host}:{port}")        try:            upstream_reader, upstream_writer = await asyncio.open_connection(host, port)        except Exception as e:            logger.error(f"Connect to {host}:{port} failed: {e}")            client_writer.write(b"HTTP/1.1 502 Bad Gateway\r\n\r\n")            await client_writer.drain()            return        full_path = urllib.parse.urlunparse(('', '', path, params, query, ''))        req_line = f"{method} {full_path} {version}\r\n"        upstream_writer.write(req_line.encode('iso-8859-1'))        connection_key = next((k for k in headers if k.lower() == 'connection'), None)        is_upgrade = False        if connection_key and 'upgrade' in headers[connection_key].lower():            is_upgrade = True        proxy_connection_key = next((k for k in headers if k.lower() == 'proxy-connection'), None)        if proxy_connection_key:            del headers[proxy_connection_key]        if not is_upgrade:            if connection_key:                del headers[connection_key]            headers['Connection'] = 'close'        for k, v in headers.items():            upstream_writer.write(f"{k}: {v}\r\n".encode('iso-8859-1'))        upstream_writer.write(b'\r\n')        await upstream_writer.drain()        await self.pipe_bi(client_reader, client_writer, upstream_reader, upstream_writer)    @staticmethod    def _get_host_port(netloc):        try:            if ':' in netloc:                host, port = netloc.split(':')                return host, int(port)            else:                return netloc, 80        except ValueError:            return None    @staticmethod    async def pipe(reader: asyncio.StreamReader, writer: asyncio.StreamWriter, source_peer: str, dest_peer: str):        try:            while True:                logger.debug(f"Pipe {source_peer} -> {dest_peer}: waiting for data...")                data = await reader.read(4096)                logger.debug(f"Pipe {source_peer} -> {dest_peer}: read {len(data)} bytes.")                if not data:                    logger.debug(f"EOF from {source_peer}, breaking pipe loop.")                    break                logger.debug(f"Pipe {source_peer} -> {dest_peer}: writing {len(data)} bytes.")                writer.write(data)                await writer.drain()                logger.debug(f"Pipe {source_peer} -> {dest_peer}: drained writer.")        except asyncio.CancelledError:            logger.debug(f"Pipe from {source_peer} to {dest_peer} cancelled.")            raise        except (ConnectionResetError, BrokenPipeError):            logger.debug(f"Connection reset/broken from {source_peer} to {dest_peer}.")        except Exception as e:            logger.error(f"Pipe error from {source_peer} to {dest_peer}: {e}", exc_info=True)        finally:            logger.debug(f"Pipe {source_peer} -> {dest_peer}: in finally block.")            if not writer.is_closing():                logger.debug(f"Closing writer to {dest_peer}.")                writer.close()                try:                    await writer.wait_closed()                except Exception:                    pass            logger.debug(f"Writer to {dest_peer} is closed.")    @staticmethod    async def pipe_bi(reader1, writer1, reader2, writer2):        peer1 = str(writer1.get_extra_info('peername'))        peer2 = str(writer2.get_extra_info('peername'))        logger.debug(f"Piping data between {peer1} and {peer2}")        task1 = asyncio.create_task(AsyncProxy.pipe(reader1, writer2, peer1, peer2), name=f"pipe_{peer1}_to_{peer2}")        task2 = asyncio.create_task(AsyncProxy.pipe(reader2, writer1, peer2, peer1), name=f"pipe_{peer2}_to_{peer1}")        done, pending = await asyncio.wait(            [task1, task2],            return_when=asyncio.FIRST_COMPLETED        )        logger.debug(f"asyncio.wait returned. Done tasks: {len(done)}, Pending tasks: {len(pending)}")        for task in pending:            logger.debug(f"Cancelling pending task: {task.get_name()}")            task.cancel()                for task in done:            try:                await task            except asyncio.CancelledError:                pass            except Exception as e:                logger.error(f"Task {task.get_name()} finished with an exception: {e}")        logger.debug(f"Pipe between {peer1} and {peer2} finished.")def usage():    parser = argparse.ArgumentParser(description=f'{__NAME__}')    parser.add_argument('-H', '--host', type=str, dest="host", default='127.0.0.1',                        help="Host to bind to [default: 127.0.0.1]")    parser.add_argument('-P', '--port', type=int, dest="port", default='8000',                        help="Port to bind to [default: 8000]")    parser.add_argument('-l', '--logfile', type=str, dest="logfile", default='STDOUT',                        help="Path to the logfile [default: STDOUT]")    parser.add_argument('-p', '--pidfile', type=str, dest="pidfile", default=None,                        help=f"Path to the pidfile [default: /tmp/{__NAME__.lower()}.pid]")    parser.add_argument('-d', '--daemon', action='store_true', dest="daemon", default=False,                        help="Daemonize (run in the background). Daemon mode must specify logfile")    parser.add_argument('-v', '--verbose', action='store_true', dest="verbose", default=False,                        help="Log debug info")    args = parser.parse_args()    if args.daemon and args.logfile in ('-', 'STDOUT'):        parser.error("Daemon mode requires a logfile path.")    return argsasync def main():    args = usage()    if not (0 < args.port < 65536):        print(f'Port[{args.port}] invalid', file=sys.stderr)        sys.exit(1)    logger = util.setup_logging(args.logfile, 20, args.verbose)    if args.daemon:        context = daemon.DaemonContext(            working_directory='/tmp',            umask=0o022,            pidfile=pidfile.TimeoutPIDLockFile(args.pidfile),            files_preserve=[handler.stream.fileno() for handler in logger.handlers],            stdout=logger.handlers[0].stream,            stderr=logger.handlers[0].stream,        )        try:            with context:                logger.info("Daemon process started.")                proxy = AsyncProxy(args.host, args.port)                await proxy.start()        except Exception as e:            logger.critical(f"Daemon failed to start: {e}")            sys.exit(1)    else:        try:            logger.info("Starting proxy in foreground.")            proxy = AsyncProxy(args.host, args.port)            await proxy.start()        except KeyboardInterrupt:            logger.info("Proxy stopped by user.")        except Exception as e:            logger.error(f"An unexpected error occurred: {e}", exc_info=True)if __name__ == '__main__':    asyncio.run(main())